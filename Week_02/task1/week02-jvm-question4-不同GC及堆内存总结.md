# Serial GC
开启方式：-XX:+UseSerialGC  
串行 GC 对年轻代使用mark-copy（标记-复制）算法，对老年代使用 mark-sweep- compact（标记-清除-整理）算法。年轻代和老年代都是单线程垃圾收集器处理，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。 
串行 GC 算法不能充分利用多核 CPU，不管有多少 CPU 内核，JVM 在垃圾收集时都只能使用单个核心。 CPU 利用率高，暂停时间长，系统会有卡死状态。 
Serial GC 适合几百 MB 堆内存的 JVM，而且是单核 CPU 时比较有用。-XX:+USeParNewGC 为改进版本的 Serial GC，可以配合 CMS 使用。


# Parallel GC
开启方式：-XX:+UseParallelGC  
JDK 默认 GC：Java 5～8  
年轻代和老年代的垃圾回收都会触发 STW 事件。
在年轻代使用标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweep- compact）算法。
-XX:ParallelGCThreads=N 指定 GC 线程数， 其默认值为 CPU 核心数。并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量:
在 GC 期间，所有 CPU内核都在并行清理垃圾，所以总暂停时间更短;
在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源。  
在不考虑延迟的情况下，并行 ParallelGC 的吞吐量是所有 GC 策略里面最大的。


# CMC GC
开启方式：-XX:+UseConcMarkSweepGC  

阶段 | 主要职责
---|---
阶段 1: Initial Mark（初始标记） | 这个阶段伴随着 ==STW== 暂停。初始标记的目标是标记所有 的根对象，包括根对象直接引用的对象，以及被年轻代中 所有存活对象所引用的对象（老年代单独回收）。
阶段 2: Concurrent Mark（并发标记） | 在此阶段，CMS GC 遍历老年代，标记所有的存活对 象，从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标记”阶段，就是与应用程序同时运行，不用暂停的 阶段。
阶段 3: Concurrent Preclean（并发预清理） | 此阶段同样是与应用线程并发执行的，不需要停止应用线 程。 因为前一阶段【并发标记】与程序并发运行，可能 有一些引用关系已经发生了改变。如果在并发标记过程中 引用关系发生了变化，JVM 会通过“Card（卡片）”的方 式将发生了改变的区域标记为“脏”区，这就是所谓的 卡 片标记（Card Marking）。
阶段 4: Final Remark（最终标记） | 最终标记阶段是此次 GC 事件中的第二次（也是最后一次）==STW== 停顿。本阶段的目标是完成老年代中所有存活 对象的标记. 因为之前的预清理阶段是并发执行的，有可 能 GC 线程跟不上应用程序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件。
阶段 5: Concurrent Sweep（并发清除） | 此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在 此阶段删除不再使用的对象，并回收他们占用的内存空 间。
阶段 6: Concurrent Reset（并发重置） | 此阶段与应用程序并发执行，重置 CMS 算法相关的内部 数据，为下一次 GC 循环做准备。


# G1 GC
开启方式：-XX:+UseG1GC  
JDK 默认 GC：Java 9～11  
G1 的全称是 Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它。 G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。事实上，G1 GC 是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。为了达成可预期停顿时间的指标，G1 GC 有一些独特的实现。首先，堆不再分成年轻代和老年代，而是划分为多个（通常是 2048 个）可以存放对象的小块堆区 域(smaller heap regions)。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起是老年代。  
通过划分更小的区域，降低GC回收区域的大小和GC暂停时间，进而提高了GC 的频率。


# GC 组合及选择
常用的组合为：  
（1）Serial+Serial Old 实现单线程的低延迟垃圾回收机制；  
（2）ParNew+CMS，实现多线程的低延迟垃圾回收机制；  
（3）Parallel Scavenge和Parallel Scavenge Old，实现多线程的高吞吐量垃圾回收机制。  

选择正确的 GC 算法，唯一可行的方式就是尝试，在关闭 JVM 自动调整的前提下，根据系统可用内存情况，配合压力测试，选择不同的 GC 策略，查看垃圾收集情况（次数、GC时间）。一般性的指导原则：  
（1）如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；  
（2）如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC；  
（3）如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。一般 4G 以上，算是比较大，用 G1 的性价比较高；超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。


# 其他
堆内存太小容易 OOM，堆内存太大也会造成每次 GC 的时间变长，STW 时间变长，业务处理时间变大，吞吐量下降。